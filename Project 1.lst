0000              1   ; EFM8_Receiver.asm:  This program implements a simple serial port
0000              2   ; communication protocol to program, verify, and read an SPI flash memory.  Since
0000              3   ; the program was developed to store wav audio files, it also allows 
0000              4   ; for the playback of said audio.  It is assumed that the wav sampling rate is
0000              5   ; 22050Hz, 8-bit, mono.
0000              6   ;
0000              7   ; Connections:
0000              8   ; 
0000              9   ; EFM8 board  SPI_FLASH
0000             10   ; P0.0        Pin 6 (SPI_CLK)
0000             11   ; P0.1        Pin 2 (MISO)
0000             12   ; P0.2        Pin 5 (MOSI)
0000             13   ; P0.3        Pin 1 (CS/)
0000             14   ; GND         Pin 4
0000             15   ; 3.3V        Pins 3, 7, 8  (The MCP1700 3.3V voltage regulator or similar is required)
0000             16   ;
0000             17   ; P3.0 is the DAC output which should be connected to the input of power amplifier (LM386 or similar)
0000             18   ;
0000             19   
                 21   $LIST
0000             23   
0000             24   SYSCLK         EQU 72000000  ; Microcontroller system clock frequency in Hz
0000             25   TIMER2_RATE    EQU 22050     ; 22050Hz is the sampling rate of the wav file we are playing
0000             26   TIMER2_RELOAD  EQU 0x10000-(SYSCLK/TIMER2_RATE)
0000             27   F_SCK_MAX      EQU 20000000
0000             28   BAUDRATE       EQU 115200
0000             29   
0000             30   FLASH_CE EQU P0.3
0000             31   SPEAKER  EQU P2.0
0000             32   
0000             33   ; Commands supported by the SPI flash memory according to the datasheet
0000             34   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             35   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             36   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             37   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             38   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             39   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             40   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             41   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             42   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             43   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             44   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             45   
0000             46   ; Variables used in the program:
0030             47   dseg at 30H
0030             48   w:   ds 3 ; 24-bit play counter.  Decremented in Timer 2 ISR.
0033             49   x:               ds      4
0037             50   y:               ds      4
003B             51   R:      ds  4
003F             52   bcd:     ds      5
0000             53   bseg
0000             54   mf:              dbit 1
0001             55   ; Interrupt vectors:
0000             56   cseg
0000             57   
0000             58   org 0x0000 ; Reset vector
0000 0202A1      59       ljmp MainProgram
0003             60   
0003             61   org 0x0003 ; External interrupt 0 vector (not used in this code)
0003 32          62            reti
0004             63   
000B             64   org 0x000B ; Timer/Counter 0 overflow interrupt vector (not used in this code)
000B 32          65            reti
000C             66   
0013             67   org 0x0013 ; External interrupt 1 vector (not used in this code)
0013 32          68            reti
0014             69   
001B             70   org 0x001B ; Timer/Counter 1 overflow interrupt vector (not used in this code
001B 32          71            reti
001C             72   
0023             73   org 0x0023 ; Serial port receive/transmit interrupt vector (not used in this code)
0023 32          74            reti
0024             75   
005B             76   org 0x005b ; Timer 2 interrupt vector.  Used in this code to replay the wave file.
005B 02012C      77            ljmp Timer2_ISR
005E             78   
005E             79   LCD_RS equ P1.7
005E             80   LCD_RW equ P1.6 
005E             81   LCD_E  equ P1.5
005E             82   LCD_D4 equ P2.2
005E             83   LCD_D5 equ P2.3
005E             84   LCD_D6 equ P2.4
005E             85   LCD_D7 equ P2.5
005E             86   ;library used
                 88   	$LIST 
011D 46726571    90   Msg1:  db 'Frequency(Hz):', 0
     75656E63
     7928487A
     293A00
012C             91   ;-------------------------------------;
012C             92   ; ISR for Timer 2.  Used to playback  ;
012C             93   ; the WAV file stored in the SPI      ;
012C             94   ; flash memory.                       ;
012C             95   ;-------------------------------------;
012C             96   Timer2_ISR:
012C 75A700      97            mov     SFRPAGE, #0x00
012F C2CF        98            clr     TF2H ; Clear Timer2 interrupt flag
0131             99   
0131            100            ; The registers used in the ISR must be saved in the stack
0131 C0E0       101            push acc
0133 C0D0       102            push psw
0135            103            
0135            104            ; Check if the play counter is zero.  If so, stop playing sound.
0135 E530       105            mov a, w+0
0137 4531       106            orl a, w+1
0139 4532       107            orl a, w+2
013B 6029       108            jz stop_playing
013D            109            
013D            110            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
013D 74FF       111            mov a, #0xff
013F 1530       112            dec w+0
0141 B53007     113            cjne a, w+0, keep_playing
0144 1531       114            dec w+1
0146 B53102     115            cjne a, w+1, keep_playing
0149 1532       116            dec w+2
014B            117            
014B            118   keep_playing:
014B            119   
014B D2A0       120            setb SPEAKER
014D 120181     121            lcall Send_SPI ; Read the next byte from the SPI Flash...
0150            122            
0150            123            ; It gets a bit complicated here because we read 8 bits from the flash but we need to write 12 bits to DAC:
0150 75A730     124            mov SFRPAGE, #0x30 ; DAC registers are in page 0x30
0153 C0E0       125            push acc ; Save the value we got from flash
0155 C4         126            swap a
0156 54F0       127            anl a, #0xf0
0158 F584       128            mov DAC0L, a
015A D0E0       129            pop acc
015C C4         130            swap a
015D 540F       131            anl a, #0x0f
015F F585       132            mov DAC0H, a
0161 75A700     133            mov SFRPAGE, #0x00
0164            134            
0164 8006       135            sjmp Timer2_ISR_Done
0166            136   
0166            137   stop_playing:
0166 C2CA       138            clr TR2 ; Stop timer 2
0168 D283       139            setb FLASH_CE  ; Disable SPI Flash
016A C2A0       140            clr SPEAKER ; Turn off speaker.  Removes hissing noise when not playing sound.
016C            141   
016C            142   Timer2_ISR_Done:         
016C D0D0       143            pop psw
016E D0E0       144            pop acc
0170 32         145            reti
0171            146   
0171            147   ;---------------------------------;
0171            148   ; Sends a byte via serial port    ;
0171            149   ;---------------------------------;
0171            150   putchar:
0171 109902     151            jbc     TI,putchar_L1
0174 80FB       152            sjmp putchar
0176            153   putchar_L1:
0176 F599       154            mov     SBUF,a
0178 22         155            ret
0179            156   
0179            157   ;---------------------------------;
0179            158   ; Receive a byte from serial port ;
0179            159   ;---------------------------------;
0179            160   getchar:
0179 109802     161            jbc     RI,getchar_L1
017C 80FB       162            sjmp getchar
017E            163   getchar_L1:
017E E599       164            mov     a,SBUF
0180 22         165            ret
0181            166   
0181            167   ;---------------------------------;
0181            168   ; Sends AND receives a byte via   ;
0181            169   ; SPI.                            ;
0181            170   ;---------------------------------;
0181            171   Send_SPI:
0181 F5A3       172            mov     SPI0DAT, a
0183            173   Send_SPI_L1:
0183 30FFFD     174            jnb     SPIF, Send_SPI_L1 ; Wait for SPI transfer complete
0186 C2FF       175            clr SPIF ; Clear SPI complete flag 
0188 E5A3       176            mov     a, SPI0DAT
018A 22         177            ret
018B            178   
018B            179   ;---------------------------------;
018B            180   ; SPI flash 'write enable'        ;
018B            181   ; instruction.                    ;
018B            182   ;---------------------------------;
018B            183   Enable_Write:
018B C283       184            clr FLASH_CE
018D 7406       185            mov a, #WRITE_ENABLE
018F 120181     186            lcall Send_SPI
0192 D283       187            setb FLASH_CE
0194 22         188            ret
0195            189   
0195            190   ;---------------------------------;
0195            191   ; This function checks the 'write ;
0195            192   ; in progress' bit of the SPI     ;
0195            193   ; flash memory.                   ;
0195            194   ;---------------------------------;
0195            195   Check_WIP:
0195 C283       196            clr FLASH_CE
0197 7405       197            mov a, #READ_STATUS
0199 120181     198            lcall Send_SPI
019C 7455       199            mov a, #0x55
019E 120181     200            lcall Send_SPI
01A1 D283       201            setb FLASH_CE
01A3 20E0EF     202            jb acc.0, Check_WIP ;  Check the Write in Progress bit
01A6 22         203            ret
01A7            204            
01A7            205   Init_all:
01A7            206            ; Disable WDT:
01A7 7597DE     207            mov     WDTCN, #0xDE
01AA 7597AD     208            mov     WDTCN, #0xAD
01AD            209            
01AD 75FF80     210            mov     VDM0CN, #0x80
01B0 75EF06     211            mov     RSTSRC, #0x06
01B3            212            
01B3            213            ; Switch SYSCLK to 72 MHz.  First switch to 24MHz:
01B3 75A710     214            mov     SFRPAGE, #0x10
01B6 75C120     215            mov     PFE0CN, #0x20
01B9 75A700     216            mov     SFRPAGE, #0x00
01BC 75A900     217            mov     CLKSEL, #0x00
01BF 75A900     218            mov     CLKSEL, #0x00 ; Second write to CLKSEL is required according to datasheet
01C2            219            
01C2            220            ; Wait for clock to settle at 24 MHz by checking the most significant bit of CLKSEL:
01C2            221   Init_L1:
01C2 E5A9       222            mov     a, CLKSEL
01C4 30E7FB     223            jnb     acc.7, Init_L1
01C7            224            
01C7            225            ; Now switch to 72MHz:
01C7 75A903     226            mov     CLKSEL, #0x03
01CA 75A903     227            mov     CLKSEL, #0x03  ; Second write to CLKSEL is required according to datasheet
01CD            228            
01CD            229            ; Wait for clock to settle at 72 MHz by checking the most significant bit of CLKSEL:
01CD            230   Init_L2:
01CD E5A9       231            mov     a, CLKSEL
01CF 30E7FB     232            jnb     acc.7, Init_L2
01D2            233   
01D2 75A700     234            mov     SFRPAGE, #0x00
01D5            235            
01D5            236            ; Configure P3.0 as analog output.  P3.0 pin is the output of DAC0.
01D5 53F4FE     237            anl     P3MDIN, #0xFE
01D8 43B001     238            orl     P3, #0x01
01DB            239            
01DB            240            ; Configure the pins used for SPI (P0.0 to P0.3)
01DB 75A41D     241            mov     P0MDOUT, #0x1D ; SCK, MOSI, P0.3, TX0 are push-pull, all others open-drain
01DE            242   
01DE 75E103     243            mov     XBR0, #0x03 ; Enable SPI and UART0: SPI0E=1, URT0E=1
01E1 75E210     244            mov     XBR1, #0x10
01E4 75E340     245            mov     XBR2, #0x40 ; Enable crossbar and weak pull-ups
01E7            246   
01E7            247            ; Enable serial communication and set up baud rate using timer 1
01E7 759810     248            mov     SCON0, #0x10    
01EA 758DE6     249            mov     TH1, #(0x100-((SYSCLK/BAUDRATE)/(12*2)))
01ED 858D8B     250            mov     TL1, TH1
01F0 53890F     251            anl     TMOD, #0x0F ; Clear the bits of timer 1 in TMOD
01F3 438920     252            orl     TMOD, #0x20 ; Set timer 1 in 8-bit auto-reload mode.  Don't change the bits of timer 0
01F6 D28E       253            setb TR1 ; START Timer 1
01F8 D299       254            setb TI ; Indicate TX0 ready
01FA            255            
01FA            256            ; Configure DAC 0
01FA 75A730     257            mov     SFRPAGE, #0x30 ; To access DAC 0 we use register page 0x30
01FD 758888     258            mov     DACGCF0, #0b_1000_1000 ; 1:D23REFSL(VCC) 1:D3AMEN(NORMAL) 2:D3SRC(DAC3H:DAC3L) 1:D01REFSL(VCC) 1:D1AMEN(NORMAL) 1:D1SRC(DAC1H:DAC1L)
0200 759800     259            mov     DACGCF1, #0b_0000_0000
0203 75A222     260            mov     DACGCF2, #0b_0010_0010 ; Reference buffer gain 1/3 for all channels
0206 759180     261            mov     DAC0CF0, #0b_1000_0000 ; Enable DAC 0
0209 759202     262            mov     DAC0CF1, #0b_0000_0010 ; DAC gain is 3.  Therefore the overall gain is 1.
020C            263            ; Initial value of DAC 0 is mid scale:
020C 758400     264            mov     DAC0L, #0x00
020F 758508     265            mov     DAC0H, #0x08
0212 75A700     266            mov     SFRPAGE, #0x00
0215            267            
0215            268            ; Configure SPI
0215 75A200     269            mov     SPI0CKR, #((SYSCLK/(2*F_SCK_MAX))-1)
0218 75A140     270            mov     SPI0CFG, #0b_0100_0000 ; SPI in master mode
021B 75F801     271            mov     SPI0CN0, #0b_0000_0001 ; SPI enabled and in three wire mode
021E D283       272            setb FLASH_CE ; CS=1 for SPI flash memory
0220 C2A0       273            clr SPEAKER ; Turn off speaker.
0222            274            
0222            275            ; Configure Timer 2 and its interrupt
0222 75C800     276            mov     TMR2CN0,#0x00 ; Stop Timer2; Clear TF2
0225 438E10     277            orl     CKCON0,#0b_0001_0000 ; Timer 2 uses the system clock
0228            278            ; Initialize reload value:
0228 75CA3F     279            mov     TMR2RLL, #low(TIMER2_RELOAD)
022B 75CBF3     280            mov     TMR2RLH, #high(TIMER2_RELOAD)
022E            281            ; Set timer to reload immediately
022E 75CFFF     282            mov     TMR2H,#0xFF
0231 75CEFF     283            mov     TMR2L,#0xFF
0234 D2AD       284            setb ET2 ; Enable Timer 2 interrupts
0236            285            ; setb TR2 ; Timer 2 is only enabled to play stored sound
0236            286            
0236            287            ; initialize Timer 0 as a 16bit counter
0236 75A700     288            mov     SFRPAGE, #0x00
0239 75D408     289            mov p0skip,#0b0000_1000
023C E589       290            mov a, TMOD
023E 54F0       291       anl a, #0b_1111_0000 ; Clear the bits of timer/counter 0
0240 4405       292       orl a, #0b_0000_0101 ; Sets the bits of timer/counter 0 for a 16-bit counter
0242 F589       293       mov TMOD, a
0244            294            
0244            295            
0244 D2AF       296            setb EA ; Enable interrupts
0246            297            
0246 22         298            ret
0247            299   
0247            300   ;---------------------------------;
0247            301   ; Main program. Includes hardware ;
0247            302   ; initialization and 'forever'    ;
0247            303   ; loop.                           ;
0247            304   ;---------------------------------;
0247            305   Wait_one_second:         
0247            306       ;For a 24.5MHz clock one machine cycle takes 1/24.5MHz=40.81633ns
0247            307   
0247 7AB7       308       mov R2, #183 ; Calibrate using this number to account for overhead delays
0249 79FF       309   X3: mov R1, #255
024B 78FF       310   X2: mov R0, #255
024D D8FE       311   X1: djnz R0, X1 ; 3 machine cycles -> 3*40.81633ns*255=31.2245us (see table 10.2 in reference manual)
024F D9FA       312       djnz R1, X2 ; 31.2245us*255=7.96224ms
0251 DAF6       313       djnz R2, X3 ; 7.96224ms*125=0.995s + overhead
0253 22         314       ret
0254            315            
0254            316   
0254            317   ;Converts the hex number in TH0-TL0 to packed BCD in R2-R1-R0
0254            318   hex2bcd:
0254 E4         319            clr a
0255 7800       320       mov R0, #0  ; Set packed BCD result to 00000 
0257 7900       321       mov R1, #0
0259 7A00       322       mov R2, #0
025B 7B10       323       mov R3, #16 ; Loop counter.
025D            324       
025D            325   hex2bcd_L0:
025D E58A       326       mov a, TL0 ; Shift TH0-TL0 left through carry
025F 33         327       rlc a
0260 F58A       328       mov TL0, a
0262            329       
0262 E58C       330       mov a, TH0
0264 33         331       rlc a
0265 F58C       332       mov TH0, a
0267            333       
0267            334            ; Perform bcd + bcd + carry
0267            335            ; using BCD numbers
0267 E8         336            mov a, R0
0268 38         337            addc a, R0
0269 D4         338            da a
026A F8         339            mov R0, a
026B            340            
026B E9         341            mov a, R1
026C 39         342            addc a, R1
026D D4         343            da a
026E F9         344            mov R1, a
026F            345            
026F EA         346            mov a, R2
0270 3A         347            addc a, R2
0271 D4         348            da a
0272 FA         349            mov R2, a
0273            350            
0273 DBE8       351            djnz R3, hex2bcd_L0
0275 22         352            ret
0276            353   
0276            354   ; Dumps the 5-digit packed BCD number in R2-R1-R0 into the LCD
0276            355   DisplayBCD:
0276            356            ; 5th digit:
0276 EA         357       mov a, R2
0277 540F       358       anl a, #0FH
0279 4430       359       orl a, #'0' ; convert to ASCII
027B 1200B6     360            lcall ?WriteData
027E            361            ; 4th digit:
027E E9         362       mov a, R1
027F C4         363       swap a
0280 540F       364       anl a, #0FH
0282 4430       365       orl a, #'0' ; convert to ASCII
0284 1200B6     366            lcall ?WriteData
0287            367            ; 3rd digit:
0287 E9         368       mov a, R1
0288 540F       369       anl a, #0FH
028A 4430       370       orl a, #'0' ; convert to ASCII
028C 1200B6     371            lcall ?WriteData
028F            372            ; 2nd digit:
028F E8         373       mov a, R0
0290 C4         374       swap a
0291 540F       375       anl a, #0FH
0293 4430       376       orl a, #'0' ; convert to ASCII
0295 1200B6     377            lcall ?WriteData
0298            378            ; 1st digit:
0298 E8         379       mov a, R0
0299 540F       380       anl a, #0FH
029B 4430       381       orl a, #'0' ; convert to ASCII
029D 1200B6     382            lcall ?WriteData
02A0            383       
02A0 22         384       ret
02A1            385   MainProgram:
02A1 75817F     386       mov SP, #0x7f ; Setup stack pointer to the start of indirectly accessable data memory minus one
02A4 1201A7     387       lcall Init_all ; Initialize the hardware
02A7 1200C0     388            lcall LCD_4BIT 
02AA C0E0       389            push acc
02AC 7401       389            mov a, #1
02AE 14         389            dec a
02AF 120102     389            lcall ?Set_Cursor_1 ; Select column and row
02B2 D0E0       389            pop acc
02B4 C083       390            push dph
02B6 C082       390            push dpl
02B8 C0E0       390            push acc
02BA 90011D     390            mov dptr, #Msg1
02BD 1200F5     390            lcall ?Send_Constant_String
02C0 D0E0       390            pop acc
02C2 D082       390            pop dpl
02C4 D083       390            pop dph
02C6            391       
02C6            392   forever_loop:
02C6 C28C       393            clr TR0 ; Stop counter 0
02C8 758A00     394       mov TL0, #0x00
02CB 758C00     395       mov TH0, #0x00
02CE D28C       396       setb TR0 ; Start counter 0
02D0 120247     397       lcall Wait_one_second
02D3 120247     398        lcall Wait_one_second
02D6 C28C       399       clr TR0 ; Stop counter 0, TH0-TL0 has the frequency
02D8            400            ; Convert the result to BCD and display on LCD
02D8 C0E0       401            push acc
02DA 7401       401            mov a, #1
02DC 14         401            dec a
02DD 120100     401            lcall ?Set_Cursor_2 ; Select column and row
02E0 D0E0       401            pop acc
02E2 120254     402       lcall hex2bcd
02E5 120276     403       lcall DisplayBCD
02E8            404       
02E8 209837     405            jb RI, serial_get
02EB 20B7D8     406            jb P3.7, forever_loop ; Check if push-button pressed
02EE 30B7FD     407            jnb P3.7, $ ; Wait for push-button release
02F1            408            ; Play the whole memory
02F1 C2CA       409            clr TR2 ; Stop Timer 2 ISR from playing previous request
02F3 D283       410            setb FLASH_CE
02F5 C2A0       411            clr SPEAKER ; Turn off speaker.
02F7            412            
02F7 C283       413            clr FLASH_CE ; Enable SPI Flash
02F9 7403       414            mov a, #READ_BYTES
02FB 120181     415            lcall Send_SPI
02FE            416            ; Set the initial position in memory where to start playing
02FE 7400       417            mov a, #0x00
0300 120181     418            lcall Send_SPI
0303 7400       419            mov a, #0x00
0305 120181     420            lcall Send_SPI
0308 7400       421            mov a, #0x00
030A 120181     422            lcall Send_SPI
030D 7400       423            mov a, #0x00 ; Request first byte to send to DAC
030F 120181     424            lcall Send_SPI
0312            425            
0312            426            ; How many bytes to play? All of them!  Asume 4Mbytes memory: 0x3fffff
0312 75323F     427            mov w+2, #0x3f
0315 7531FF     428            mov w+1, #0xff
0318 7530FF     429            mov w+0, #0xff
031B            430            
031B D2A0       431            setb SPEAKER ; Turn on speaker.
031D D2CA       432            setb TR2 ; Start playback by enabling Timer 2
031F 0202C6     433            ljmp forever_loop
0322            434            
0322            435   serial_get:
0322 120179     436            lcall getchar ; Wait for data to arrive
0325 B4239E     437            cjne a, #'#', forever_loop ; Message format is #n[data] where 'n' is '0' to '9'
0328 C2CA       438            clr TR2 ; Stop Timer 2 from playing previous request
032A D283       439            setb FLASH_CE ; Disable SPI Flash       
032C C2A0       440            clr SPEAKER ; Turn off speaker.
032E 120179     441            lcall getchar
0331            442   
0331            443   ;---------------------------------------------------------       
0331 B43024     444            cjne a, #'0' , Command_0_skip
0334            445   Command_0_start: ; Identify command
0334 C283       446            clr FLASH_CE ; Enable SPI Flash         
0336 749F       447            mov a, #READ_DEVICE_ID
0338 120181     448            lcall Send_SPI  
033B 7455       449            mov a, #0x55
033D 120181     450            lcall Send_SPI
0340 120171     451            lcall putchar
0343 7455       452            mov a, #0x55
0345 120181     453            lcall Send_SPI
0348 120171     454            lcall putchar
034B 7455       455            mov a, #0x55
034D 120181     456            lcall Send_SPI
0350 120171     457            lcall putchar
0353 D283       458            setb FLASH_CE ; Disable SPI Flash
0355 0202C6     459            ljmp forever_loop       
0358            460   Command_0_skip:
0358            461   
0358            462   ;---------------------------------------------------------       
0358 B43117     463            cjne a, #'1' , Command_1_skip 
035B            464   Command_1_start: ; Erase whole flash (takes a long time)
035B 12018B     465            lcall Enable_Write
035E C283       466            clr FLASH_CE
0360 74C7       467            mov a, #ERASE_ALL
0362 120181     468            lcall Send_SPI
0365 D283       469            setb FLASH_CE
0367 120195     470            lcall Check_WIP
036A 7401       471            mov a, #0x01 ; Send 'I am done' reply
036C 120171     472            lcall putchar           
036F 0202C6     473            ljmp forever_loop       
0372            474   Command_1_skip:
0372            475   
0372            476   ;---------------------------------------------------------       
0372 B43235     477            cjne a, #'2' , Command_2_skip 
0375            478   Command_2_start: ; Load flash page (256 bytes or less)
0375 12018B     479            lcall Enable_Write
0378 C283       480            clr FLASH_CE
037A 7402       481            mov a, #WRITE_BYTES
037C 120181     482            lcall Send_SPI
037F 120179     483            lcall getchar ; Address bits 16 to 23
0382 120181     484            lcall Send_SPI
0385 120179     485            lcall getchar ; Address bits 8 to 15
0388 120181     486            lcall Send_SPI
038B 120179     487            lcall getchar ; Address bits 0 to 7
038E 120181     488            lcall Send_SPI
0391 120179     489            lcall getchar ; Number of bytes to write (0 means 256 bytes)
0394 F8         490            mov r0, a
0395            491   Command_2_loop:
0395 120179     492            lcall getchar
0398 120181     493            lcall Send_SPI
039B D8F8       494            djnz r0, Command_2_loop
039D D283       495            setb FLASH_CE
039F 120195     496            lcall Check_WIP
03A2 7401       497            mov a, #0x01 ; Send 'I am done' reply
03A4 120171     498            lcall putchar           
03A7 0202C6     499            ljmp forever_loop       
03AA            500   Command_2_skip:
03AA            501   
03AA            502   ;---------------------------------------------------------       
03AA B4332C     503            cjne a, #'3' , Command_3_skip 
03AD            504   Command_3_start: ; Read flash bytes (256 bytes or less)
03AD C283       505            clr FLASH_CE
03AF 7403       506            mov a, #READ_BYTES
03B1 120181     507            lcall Send_SPI
03B4 120179     508            lcall getchar ; Address bits 16 to 23
03B7 120181     509            lcall Send_SPI
03BA 120179     510            lcall getchar ; Address bits 8 to 15
03BD 120181     511            lcall Send_SPI
03C0 120179     512            lcall getchar ; Address bits 0 to 7
03C3 120181     513            lcall Send_SPI
03C6 120179     514            lcall getchar ; Number of bytes to read and send back (0 means 256 bytes)
03C9 F8         515            mov r0, a
03CA            516   
03CA            517   Command_3_loop:
03CA 7455       518            mov a, #0x55
03CC 120181     519            lcall Send_SPI
03CF 120171     520            lcall putchar
03D2 D8F6       521            djnz r0, Command_3_loop
03D4 D283       522            setb FLASH_CE   
03D6 0202C6     523            ljmp forever_loop       
03D9            524   Command_3_skip:
03D9            525   
03D9            526   ;---------------------------------------------------------       
03D9 B43436     527            cjne a, #'4' , Command_4_skip 
03DC            528   Command_4_start: ; Playback a portion of the stored wav file
03DC C2CA       529            clr TR2 ; Stop Timer 2 ISR from playing previous request
03DE D283       530            setb FLASH_CE
03E0            531            
03E0 C283       532            clr FLASH_CE ; Enable SPI Flash
03E2 7403       533            mov a, #READ_BYTES
03E4 120181     534            lcall Send_SPI
03E7            535            ; Get the initial position in memory where to start playing
03E7 120179     536            lcall getchar
03EA 120181     537            lcall Send_SPI
03ED 120179     538            lcall getchar
03F0 120181     539            lcall Send_SPI
03F3 120179     540            lcall getchar
03F6 120181     541            lcall Send_SPI
03F9            542            ; Get how many bytes to play
03F9 120179     543            lcall getchar
03FC F532       544            mov w+2, a
03FE 120179     545            lcall getchar
0401 F531       546            mov w+1, a
0403 120179     547            lcall getchar
0406 F530       548            mov w+0, a
0408            549            
0408 7400       550            mov a, #0x00 ; Request first byte to send to DAC
040A 120181     551            lcall Send_SPI
040D            552            
040D D2CA       553            setb TR2 ; Start playback by enabling timer 2
040F 0202C6     554            ljmp forever_loop       
0412            555   Command_4_skip:
0412            556   
0412            557   ;---------------------------------------------------------       
0412 B4355C     558            cjne a, #'5' , Command_5_skip 
0415            559   Command_5_start: ; Calculate and send CRC-16 of ISP flash memory from zero to the 24-bit passed value.
0415            560            ; Get how many bytes to use to calculate the CRC.  Store in [r5,r4,r3]
0415 120179     561            lcall getchar
0418 FD         562            mov r5, a
0419 120179     563            lcall getchar
041C FC         564            mov r4, a
041D 120179     565            lcall getchar
0420 FB         566            mov r3, a
0421            567            
0421            568            ; Since we are using the 'djnz' instruction to check, we need to add one to each byte of the counter.
0421            569            ; A side effect is that the down counter becomes efectively a 23-bit counter, but that is ok
0421            570            ; because the max size of the 25Q32 SPI flash memory is 400000H.
0421 0B         571            inc r3
0422 0C         572            inc r4
0423 0D         573            inc r5
0424            574            
0424            575            ; Initial CRC must be zero.
0424 75A720     576            mov     SFRPAGE, #0x20 ; UART0, CRC, and SPI can work on this page
0427 75CE08     577            mov     CRC0CN0, #0b_0000_1000 ; // Initialize hardware CRC result to zero;
042A            578   
042A C283       579            clr FLASH_CE
042C 7403       580            mov a, #READ_BYTES
042E 120181     581            lcall Send_SPI
0431 E4         582            clr a ; Address bits 16 to 23
0432 120181     583            lcall Send_SPI
0435 E4         584            clr a ; Address bits 8 to 15
0436 120181     585            lcall Send_SPI
0439 E4         586            clr a ; Address bits 0 to 7
043A 120181     587            lcall Send_SPI
043D F5A3       588            mov     SPI0DAT, a ; Request first byte from SPI flash
043F 800B       589            sjmp Command_5_loop_start
0441            590   
0441            591   Command_5_loop:
0441 30FFFD     592            jnb SPIF, Command_5_loop        ; Check SPI Transfer Completion Flag
0444 C2FF       593            clr SPIF                                    ; Clear SPI Transfer Completion Flag        
0446 E5A3       594            mov a, SPI0DAT                          ; Save received SPI byte to accumulator
0448 F5A3       595            mov SPI0DAT, a                          ; Request next byte from SPI flash; while it arrives we calculate the CRC:
044A F5CA       596            mov     CRC0IN, a               ; Feed new byte to hardware CRC calculator
044C            597   
044C            598   Command_5_loop_start:
044C            599            ; Drecrement counter:
044C DBF3       600            djnz r3, Command_5_loop
044E DCF1       601            djnz r4, Command_5_loop
0450 DDEF       602            djnz r5, Command_5_loop
0452            603   Command_5_loop2:         
0452 30FFFD     604            jnb SPIF, Command_5_loop2       ; Check SPI Transfer Completion Flag
0455 C2FF       605            clr SPIF                                ; Clear SPI Transfer Completion Flag
0457 E5A3       606            mov a, SPI0DAT              ; This dummy read is needed otherwise next transfer fails (why?)
0459 D283       607            setb FLASH_CE                           ; Done reading from SPI flash
045B            608            
045B            609            ; Computation of CRC is complete.  Send 16-bit result using the serial port
045B 75CE01     610            mov     CRC0CN0, #0x01 ; Set bit to read hardware CRC high byte
045E E5CB       611            mov     a, CRC0DAT
0460 120171     612            lcall putchar
0463            613   
0463 75CE00     614            mov     CRC0CN0, #0x00 ; Clear bit to read hardware CRC low byte
0466 E5CB       615            mov     a, CRC0DAT
0468 120171     616            lcall putchar
046B            617            
046B 75A700     618            mov     SFRPAGE, #0x00
046E            619   
046E 0202C6     620            ljmp forever_loop       
0471            621   Command_5_skip:
0471            622   
0471            623   ;---------------------------------------------------------       
0471 B43635     624            cjne a, #'6' , Command_6_skip 
0474            625   Command_6_start: ; Fill flash page (256 bytes)
0474 12018B     626            lcall Enable_Write
0477 C283       627            clr FLASH_CE
0479 7402       628            mov a, #WRITE_BYTES
047B 120181     629            lcall Send_SPI
047E 120179     630            lcall getchar ; Address bits 16 to 23
0481 120181     631            lcall Send_SPI
0484 120179     632            lcall getchar ; Address bits 8 to 15
0487 120181     633            lcall Send_SPI
048A 120179     634            lcall getchar ; Address bits 0 to 7
048D 120181     635            lcall Send_SPI
0490 120179     636            lcall getchar ; Byte to write
0493 F9         637            mov r1, a
0494 7800       638            mov r0, #0 ; 256 bytes
0496            639   Command_6_loop:
0496 E9         640            mov a, r1
0497 120181     641            lcall Send_SPI
049A D8FA       642            djnz r0, Command_6_loop
049C D283       643            setb FLASH_CE
049E 120195     644            lcall Check_WIP
04A1 7401       645            mov a, #0x01 ; Send 'I am done' reply
04A3 120171     646            lcall putchar           
04A6 0202C6     647            ljmp forever_loop       
04A9            648   Command_6_skip:
04A9            649   
04A9 0202C6     650            ljmp forever_loop
04AC            651   
04AC            652   END
